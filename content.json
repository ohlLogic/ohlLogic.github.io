{"pages":[{"title":"about","text":"简介","link":"/about/index.html"}],"posts":[{"title":"常用排序模板","text":"算法排序分类 插入：插入排序，折半排序，希尔排序 交换：冒泡排序，快速排序 选择：简单排序，堆排序 归并：归并排序 基数 1.插入排序基本思想：假定前面是已经排序完成的序列，从当前位置i出发选择该位置元素arr[i]的应该在排序完成序列的位置，定位就是找到arr[j] &lt; arr[i] 1234567891011121314151617public void insertSort(int[] arr){ if(arr == null || arr.length &lt; 2) return; for(int i = 1; i &lt; arr.length; i++) { int temp = arr[i]; int j = i - 1; while(j &gt;= 0 || temp &lt; arr[j]) { arr[j + 1] = arr[j]; j--; } a[j + 1] = temp; }} 2.希尔排序基本思想：按增量进行分组，每组使用插入排序。 12345678910111213141516171819public void shellSort(int[] arr){ if(arr == null || arr.length &lt; 2) return; for(int d = arr.length &gt;&gt; 2; d &gt; 0; d &gt;&gt;= 1) //增量d { for(int i = d; i &lt; arr.length; i++) { int temp = arr[i]; int j = i - d; while(j &gt;= 0 &amp;&amp; temp &lt; arr[j]) { arr[j + d] = arr[j]; j -= d; } arr[j + d] = temp; } }} 3.折半插入基本思想：在插入排序的基础上， 将利用二分进行查找。 12345678910111213141516171819202122public void binarySort(int[] arr){ if(arr == null || arr.length &lt; 2) return; for(int i = 1; i &lt; arr.length; i++) { int left = 0, right = i - 1; int temp = arr[i]; //二分 while(left &lt;= right) { int mid = left + right &gt;&gt; 1; if(temp &lt; arr[mid]) right = mid - 1; else if(temp &gt; arr[mid]) left = mid + 1; } //移动arr[left,...,i-1] for(int j = i; j &gt; left; j--) arr[j] = arr[j - 1]; arr[left] = temp; }} 4.冒泡排序基本思想：每次比较相邻元素，每趟交换完能确定一个元素所在位置。 12345678910111213141516171819202122public void bubbleSort(int[] arr){ if(arr == null || arr.length &lt; 2) return; for(int i = 0, flag = true; i &lt; arr.length - 1; i++) //躺数 { flag = true; for(int j = 0; j &lt; arr.length - 1 - i; j++) { if(arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; } } //如果这趟没有元素交换，说明冒泡排序结束 if(flag) return; }} 5.✨快速排序基本思想：确定划分元素temp=arr[l + r &gt;&gt; 1]，从左到右找到大于temp元素，从右到左找到小于temp元素，交换。递归 1234567891011121314151617181920212223public void quickSort(int[] arr, int l, int r){ if(l &gt;= r) return; int temp = arr[l + r &gt;&gt; 1], i = l - 1, j = r + 1; while(i &lt; j) { //从前向后找到比temp大的元素 do i++; while(arr[i] &lt; temp); //从后向前找到比temp小的元素 do j--; while(arr[j] &gt; temp); //swap if(i &lt; j) { int tt = arr[j]; arr[j] = arr[i]; arr[i] = tt; } } quickSort(arr, l, j); quickSort(arr, j + 1, r);} 6.选择排序基本思想：每趟遍历记录最小元素的下标，能确定最小元素的位置。 1234567891011121314151617181920public void selectSort(int[] arr){ if(arr == null || arr.length &lt; 2) return; for(int i = 0; i &lt; arr.length; i++) { int k = i; for(int j = i + 1; j &lt; a.length; j++) { if(arr[j] &lt; arr[k]) k = j; } } if(k != i) { int temp = a[k]; a[k] = a[i]; a[i] = temp; }} 7.✨堆排序堆排序：具有特殊性质的完全二叉树。 大根堆：arr[i] &gt;= arr[2i + 1] &amp;&amp; arr[i] &gt;= arr[2i + 2] 小根堆：arr[i] &lt;= arr[2i + 1] &amp;&amp; arr[i] &lt;= arr[2i + 2] 基本思想：先构建一个堆，再将堆顶元素与末尾元素交换将最大元素沉到数组末尾。 12345678910111213141516171819202122232425262728293031323334public void heapSort(int[] arr){ if(arr == null || arr.length &lt; 2) return; //构建heap int mid = arr.length &gt;&gt; 1; for(int i = mid; i &gt;= 0; i--) adjustHeap(arr, arr.length, i); //交换 for(int i = arr.length - 1; i &gt;= 0; i--) { int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; adjustHeap(arr, i, 0); }}public void adjustHeap(int[] arr, int size, int parent){ int left = parent * 2 + 1, right = parent * 2 + 2; int max = parent; if(left &lt; size &amp;&amp; arr[left] &gt; arr[max]) max = left; if(right &lt; size &amp;&amp; arr[right] &gt; arr[max]) max = right; if(parent != max) { int temp = arr[max]; arr[max] = arr[parent]; arr[parent] = temp; adjustHeap(a, size, max); }} 8.✨归并排序123456789101112131415161718192021int[] temp = new int[N];public void mergeSort(int[] arr, int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); int k = 0, i = l, j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(arr[i] &lt; arr[j]) temp[k++] = arr[i++]; else temp[k++] = arr[j++]; } while(i &lt;= mid) temp[k++] = arr[i++]; while(j &lt;= r) temp[k++] = arr[j++]; for(i = l, j = 0; i &lt;= r; i++, j++) arr[i] = temp[j];}","link":"/2022/03/30/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}]}